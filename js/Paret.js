//DEPENDENCIES: Vector, Espai// ARGUMENTS: p1 i p2 son dos punts (Vector) per on passa la paret//           la paret es dibuixa entre aquests dos punts tot i ser infinitafunction Paret(p1,p2){		this.p1 = p1;	this.p2 = p2;	if (Math.abs(p1.y-p2.y)<Math.abs(p1.x-p2.x)) { 		this.A = (p1.y-p2.y)/(p1.x-p2.x);		this.B = -1;		this.C = (p2.x*p1.y-p1.x*p2.y)/(p2.x-p1.x);	} else {		this.A = 1;		this.B = -(p1.x-p2.x)/(p1.y-p2.y);		this.C = (p2.x*p1.y-p1.x*p2.y)/(p2.y-p1.y);	};	// Distancia d'un punt a la paret	this.distancia = function(p) {		return Math.abs(this.A*p.x+this.B*p.y+this.C)/Math.sqrt(Math.pow(this.A,2)+Math.pow(this.B,2));	},	// Vector paral.lel a la paret	this.direccio = function() {		return Vector.resta(this.p2,this.p1);	},	// Vector perpendicular a la paret	this.normal = function() {		var dir = this.direccio();		return (new Vector(-dir.y,dir.x)).normalitza();	},	this.draw = function (espai) { 		espai.strokeStyle('#000000');		espai.lineWidth(2);		espai.beginPath();				espai.moveTo(this.p1.x,this.p1.y);		espai.lineTo(this.p2.x,this.p2.y);			espai.closePath();				espai.stroke();	}		this.rebot = function(particula){		var pjvn,vn, vt, vf, cp, c1, c2;		if (this.distancia(particula.pos)<particula.radi) {			pjvn = Vector.escalar(particula.vel,this.normal());			vn = Vector.escala(this.normal(),pjvn);			vt = Vector.resta(particula.vel,vn);			vf = Vector.resta(vt,Vector.escala(vn,particula.restitucio));			particula.vel = vf;			cp = this.normal().x*particula.pos.y-this.normal().y*particula.pos.x;			c1 = (-this.normal().x*this.C-cp*this.B)/(this.normal().y*this.B+this.normal().x*this.A);			c2 = -(this.normal().y*this.C-cp*this.A)/(this.normal().y*this.B+this.normal().x*this.A);			if (pjvn>0) {				particula.pos = Vector.resta(new Vector(c1,c2),Vector.escala(this.normal(),particula.radi));			} else {				particula.pos = Vector.suma(new Vector(c1,c2),Vector.escala(this.normal(),particula.radi));			}			return true;		} else {			return false;		}	};};		